---
description: 
globs: 
alwaysApply: true
---
Okay, here is the revised Supabase Knowledge Base, formatted in Markdown, incorporating the ability to use either uploaded files or external links for media, removing Google Drive, and including specific instructions for Cursor AI development practices.
     # Menu 360 - Supabase Knowledge Base (for Cursor AI Development)

**Version:** 1.1
**Last Updated:** 2024-08-15

---

## Table of Contents

1.  **Introduction**
    *   Purpose of this Document
    *   Supabase Role in Menu 360
    *   Target Audience
2.  **Instructions for Cursor AI Development**
    *   Development Workflow
    *   Code Modification & Cleanup
    *   Testing & Validation
    *   Error Handling
3.  **Prerequisites**
    *   Supabase Account
    *   Basic Understanding of SQL and JavaScript
4.  **Supabase Project Setup**
    *   Creating a New Project
    *   Obtaining API Keys (URL, Anon Key, Service Role Key)
    *   Understanding Supabase Services Used
5.  **Database Schema & Setup**
    *   Schema Design Philosophy
    *   Table Definitions (SQL)
    *   Relationships & Foreign Keys
    *   Row Level Security (RLS) Policies Setup
6.  **Authentication (Supabase Auth)**
    *   User Roles (Owner, Staff, Customer)
    *   Setup Authentication Methods (Email/Password)
    *   Managing User Roles (`staff` table approach)
    *   Integrating Auth
7.  **Storage (Supabase Storage) & Media Handling**
    *   Rationale for Using Supabase Storage
    *   Creating Storage Buckets (`menu-media`, `marketing-assets`)
    *   Bucket Policies (Public Read for Menu, Restricted Write)
    *   **Handling Media Input (Upload vs. Link)**
    *   **Retrieving Media Source (URL or Supabase Path)**
    *   **Linking Media to Database Records (`menu_items`)**
    *   Deleting Unused Media Files (from Storage)
8.  **Realtime Functionality (Supabase Realtime)**
    *   Enabling Realtime on Tables
    *   Subscribing to Changes
    *   Use Cases
9.  **Serverless Functions (Supabase Edge Functions)**
    *   Potential Use Cases
    *   Basic Function Setup
10. **Integration & Data Flow (with Frontend/Lovable.dev)**
    *   Connecting to Supabase
    *   Fetching Data (Handling Media Sources)
    *   Performing CRUD Operations (Handling Media Input)
    *   Handling Data Synchronization
11. **Data Management & Workflows**
    *   Customer Order Flow (Data Perspective)
    *   Menu Update Flow (Data Perspective - Incl. Media)
    *   Staff Management Flow (Data Perspective)
    *   Ensuring Data Integrity
12. **Maintenance & Best Practices**
    *   Database Backups
    *   Monitoring Usage & Logs
    *   Security Best Practices
    *   Schema Migrations
    *   Cleaning Up Unused Storage Objects
13. **Troubleshooting**
    *   Common Connection Issues
    *   RLS Policy Errors
    *   Storage Access Problems
    *   Debugging Realtime Issues

---

## 1. Introduction

*   **Purpose:** This document serves as the central specification and knowledge base for setting up, configuring, and utilizing Supabase as the backend for the **Menu 360** application. It provides step-by-step instructions and best practices intended for development using **Cursor AI**.
*   **Supabase Role:** Supabase provides critical backend services: Database (PostgreSQL), Authentication, Realtime Subscriptions, Storage (for user-uploaded media files), and potentially Serverless Functions.
*   **Target Audience:** Cursor AI, developers, and administrators working on the Menu 360 application.

## 2. Instructions for Cursor AI Development

*   **Development Workflow:**
    *   Implement features **sequentially**, following the steps outlined in this KB and associated prompts.
    *   After implementing each major section (e.g., Database Setup, Auth, Storage Upload, Media Display), perform targeted testing (See Testing & Validation).
    *   Commit changes frequently with clear messages referencing the feature or fix being implemented.
*   **Code Modification & Cleanup:**
    *   When modifying existing code (based on prompts or bug fixes), carefully analyze the surrounding code to ensure changes integrate smoothly and don't break other functionalities (non-regression).
    *   **Crucially:** After modifying or refactoring code, **actively identify and delete** any resulting unused files, folders, functions, variables, state elements, or CSS classes. This is essential for maintaining a clean, efficient, and understandable codebase. Use Cursor AI's refactoring and code analysis capabilities to assist in this cleanup.
*   **Testing & Validation:**
    *   Test **each CRUD operation** (Create, Read, Update, Delete) for relevant features (Menu Items, Categories, Staff, Orders).
    *   Test across **all user roles** (Owner, Staff roles, Customer) to ensure permissions (RLS) and UI are correct.
    *   Specifically test the **media handling**: Uploading files (3D, GIF, Image), inputting external URLs, saving items, and verifying correct display in *all* relevant locations (Admin list, Customer QR menu).
    *   Verify **Realtime updates** function as expected (e.g., order notifications).
    *   Check the browser's developer console **constantly** during testing for errors.
*   **Error Handling:**
    *   Implement robust error handling for **all** Supabase interactions (database queries, auth calls, storage operations, function invocations).
    *   Display clear, user-friendly error messages in the UI rather than failing silently or showing raw error codes.

## 3. Prerequisites

*   **Supabase Account:** An active Supabase account ([https://supabase.com/](https://supabase.com/)).
*   **Basic Understanding:** Familiarity with SQL concepts and JavaScript is beneficial for understanding the underlying operations.

## 4. Supabase Project Setup

*   **Creating a New Project:**
    1.  Log in to Supabase dashboard.
    2.  Click "New project". Choose organization.
    3.  Project Name: `Menu-360-Backend` (or similar).
    4.  Generate/Enter Database Password ( **SAVE SECURELY** ).
    5.  Select Region (close to primary user base).
    6.  Choose Pricing Plan (Free tier initially).
    7.  Click "Create new project".
*   **Obtaining API Keys:**
    1.  Project Dashboard -> `Project Settings` (Gear icon) -> `API`.
    2.  Note `Project URL`.
    3.  Note `anon` `public` key (safe for client-side code).
    4.  Note `service_role` `secret` key ( **KEEP SECRET**, use only server-side or in trusted Edge Functions).
*   **Supabase Services Used:** Database, Auth, Storage, Realtime, Edge Functions (optional).

## 5. Database Schema & Setup

*   **Schema Design Philosophy:** Normalize data, use clear names, define relationships for integrity.
*   **Table Definitions (SQL):** Execute in Supabase SQL Editor (`SQL Editor` > `+ New query`).

```sql
-- Enable UUID generation if not already enabled
-- create extension if not exists "uuid-ossp" with schema extensions;

-- Restaurants Table
CREATE TABLE restaurants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    address TEXT,
    phone_number TEXT,
    owner_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- Link to the owner's Supabase auth user
    theme_color TEXT DEFAULT '#FFFFFF', -- For dynamic themes
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Menu Categories Table
CREATE TABLE menu_categories (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID REFERENCES restaurants(id) ON DELETE CASCADE NOT NULL, -- Ensure category belongs to a restaurant
    name TEXT NOT NULL,
    description TEXT,
    display_order INT DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE (restaurant_id, name) -- Category names unique per restaurant
);

-- Menu Items Table
CREATE TABLE menu_items (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    category_id UUID REFERENCES menu_categories(id) ON DELETE CASCADE NOT NULL, -- Ensure item belongs to a category
    name TEXT NOT NULL,
    description TEXT,
    price DECIMAL(10, 2) NOT NULL CHECK (price >= 0),
    -- Media Handling: Store EITHER a path in Supabase Storage OR an external URL
    media_type TEXT CHECK (media_type IN ('image', 'gif', '3d', 'none')), -- Type of media CONTENT
    media_path TEXT NULL, -- Path within the Supabase Storage bucket (e.g., 'public/item_abc.jpg') - ONLY if uploaded
    external_media_url TEXT NULL, -- External URL for the media - ONLY if link provided
    -- Dietary/Allergen Info
    is_vegetarian BOOLEAN DEFAULT false,
    is_vegan BOOLEAN DEFAULT false,
    is_gluten_free BOOLEAN DEFAULT false,
    allergens TEXT[], -- Array of allergen strings
    is_available BOOLEAN DEFAULT true,
    display_order INT DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    -- Constraint: Ensure only one media source type is stored per item
    CONSTRAINT check_media_source CHECK (
        (media_path IS NOT NULL AND external_media_url IS NULL) -- Uploaded file
        OR (media_path IS NULL AND external_media_url IS NOT NULL) -- External link
        OR (media_path IS NULL AND external_media_url IS NULL) -- No media
    )
);

-- Customers Table
CREATE TABLE customers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    phone_number TEXT UNIQUE,
    email TEXT UNIQUE,
    loyalty_points INT DEFAULT 0 CHECK (loyalty_points >= 0),
    last_visit TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT now(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL UNIQUE -- Optional link to auth user
);

-- Tables (Restaurant Tables)
CREATE TABLE tables (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID REFERENCES restaurants(id) ON DELETE CASCADE NOT NULL,
    table_number TEXT NOT NULL,
    qr_code_id UUID UNIQUE, -- Optional link to specific QR code config
    capacity INT,
    status TEXT DEFAULT 'available' CHECK (status IN ('available', 'occupied', 'reserved', 'cleaning')),
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE (restaurant_id, table_number) -- Table numbers unique per restaurant
);

-- QR Codes Table (Optional - if needing persistent, customizable QR codes)
CREATE TABLE qr_codes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    table_id UUID REFERENCES tables(id) ON DELETE CASCADE UNIQUE NOT NULL, -- QR code must belong to a table
    -- Add fields for customization if needed
    created_at TIMESTAMPTZ DEFAULT now()
);
-- Add the foreign key constraint back to tables table
ALTER TABLE tables ADD CONSTRAINT fk_qr_code FOREIGN KEY (qr_code_id) REFERENCES qr_codes(id) ON DELETE SET NULL;


-- Orders Table
CREATE TABLE orders (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID REFERENCES restaurants(id) ON DELETE CASCADE NOT NULL,
    customer_id UUID REFERENCES customers(id) ON DELETE SET NULL,
    table_id UUID REFERENCES tables(id) ON DELETE SET NULL,
    order_date TIMESTAMPTZ DEFAULT now(),
    total_amount DECIMAL(10, 2) NOT NULL CHECK (total_amount >= 0),
    status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'preparing', 'served', 'completed', 'cancelled')),
    payment_status TEXT DEFAULT 'unpaid' CHECK (payment_status IN ('unpaid', 'paid', 'failed')),
    payment_gateway_ref TEXT, -- Reference from PayU Money
    notes TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Order Items Table
CREATE TABLE order_items (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_id UUID REFERENCES orders(id) ON DELETE CASCADE NOT NULL,
    menu_item_id UUID REFERENCES menu_items(id) ON DELETE RESTRICT, -- Prevent deleting menu item if in an order
    quantity INT NOT NULL CHECK (quantity > 0),
    price_at_order DECIMAL(10, 2) NOT NULL, -- Store price at time of order
    notes TEXT, -- Item specific notes
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Staff Table
CREATE TABLE staff (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID REFERENCES restaurants(id) ON DELETE CASCADE NOT NULL,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE NOT NULL, -- Link to Supabase auth user
    role TEXT NOT NULL CHECK (role IN ('manager', 'waiter', 'chef', 'owner')),
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Ratings Table (Optional)
CREATE TABLE ratings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    customer_id UUID REFERENCES customers(id) ON DELETE SET NULL,
    menu_item_id UUID REFERENCES menu_items(id) ON DELETE CASCADE,
    order_id UUID REFERENCES orders(id) ON DELETE SET NULL,
    rating INT NOT NULL CHECK (rating >= 1 AND rating <= 5),
    comment TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Marketing Campaigns Table (Optional)
CREATE TABLE marketing_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID REFERENCES restaurants(id) ON DELETE CASCADE NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    start_date TIMESTAMPTZ,
    end_date TIMESTAMPTZ,
    target_platform TEXT,
    content TEXT,
    status TEXT DEFAULT 'draft' CHECK (status IN ('draft', 'scheduled', 'active', 'completed', 'archived')),
    created_by UUID REFERENCES staff(id) ON DELETE SET NULL, -- Link to staff user who created it
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Add indexes for frequently queried columns
CREATE INDEX idx_orders_restaurant_status ON orders(restaurant_id, status);
CREATE INDEX idx_menu_items_category ON menu_items(category_id);
CREATE INDEX idx_staff_user ON staff(user_id);
CREATE INDEX idx_customers_phone ON customers(phone_number);
CREATE INDEX idx_menu_items_media ON menu_items(media_path, external_media_url); -- Index for media lookup
   
Relationships: Foreign keys defined above link tables. Review ON DELETE actions (CASCADE, SET NULL, RESTRICT).
Row Level Security (RLS): CRITICAL for security and multi-tenancy.
Navigate to Authentication > Policies in Supabase Dashboard.
Enable RLS for each table defined above.
Create Policies: Define policies meticulously based on user roles (auth.uid(), checking staff table via helper functions or joins). Examples:
restaurants: Owners manage their own; Staff can read their assigned restaurant.
menu_items: Owners/Managers manage items for their restaurant; Authenticated users/Public can read.
orders: Staff view/update orders for their restaurant; Customers view their own orders.
staff: Owners/Managers manage staff for their restaurant; Staff view their own record.
customers: Owners/Managers view customers linked to their restaurant's orders; Customers view/update their own profile (if logged in).


Example RLS Policy Structure (Conceptual - Adapt needed helper functions):
      -- Function to check if a user is staff of a specific restaurant with certain roles
CREATE OR REPLACE FUNCTION is_restaurant_staff(user_id_input UUID, restaurant_id_input UUID, required_roles TEXT[])
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM staff
    WHERE user_id = user_id_input
      AND restaurant_id = restaurant_id_input
      AND role = ANY(required_roles)
      AND is_active = true
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER; -- SECURITY DEFINER allows function to check staff table even if user can't directly

-- Policy for menu_items: Owners/Managers can do anything for their restaurant
CREATE POLICY "Owners/Managers manage menu items"
ON menu_items
FOR ALL -- SELECT, INSERT, UPDATE, DELETE
USING (
  is_restaurant_staff(auth.uid(), (SELECT restaurant_id FROM menu_categories WHERE id = category_id), ARRAY['owner', 'manager'])
)
WITH CHECK (
  is_restaurant_staff(auth.uid(), (SELECT restaurant_id FROM menu_categories WHERE id = category_id), ARRAY['owner', 'manager'])
);

-- Policy for menu_items: Authenticated users can read
CREATE POLICY "Authenticated read access for menu items"
ON menu_items
FOR SELECT
USING (auth.role() = 'authenticated');
   
 IGNORE_WHEN_COPYING_START
 content_copy download
 Use code with caution.SQL
IGNORE_WHEN_COPYING_END
Note: Implementing robust RLS, especially involving joins or checking roles from other tables, requires careful design. Use helper functions (SECURITY DEFINER where appropriate) for clarity and reusability. Test RLS policies thoroughly.


6. Authentication (Supabase Auth)
User Roles: Owner, Manager, Waiter, Chef, Customer.
Setup Auth Methods:
Go to Authentication > Providers.
Enable Email. Configure settings.


Managing User Roles (staff table approach - Recommended):
Use the staff table (linked to auth.users via user_id) to define roles within a specific restaurant_id.
Owners identified by restaurants.owner_id OR a role in the staff table.
Permissions enforced via RLS policies checking the staff table using auth.uid().


Integrating Auth:
Use frontend framework/Lovable.dev Supabase Auth actions/components.
Implement login (signInWithPassword), signup (signUp), password reset (resetPasswordForEmail).
Securely manage session/JWT token on the client. Authenticate Supabase API requests.


7. Storage (Supabase Storage) & Media Handling
Rationale: Use Supabase Storage for integrated media handling alongside the database, simplifying permissions and access.
Creating Storage Buckets:
Go to Storage in Supabase dashboard.
Click + New bucket.
Create menu-media: Tick Public bucket. (Allows direct public URL access).
(Optional) Create marketing-assets: Leave Public bucket unticked (requires signed URLs or RLS policies for access).


Bucket Policies (RLS for Storage): Control who can perform which actions (SELECT, INSERT, UPDATE, DELETE) on storage objects.
Go to Storage > Policies.
menu-media Bucket:
SELECT: Public read is enabled by ticking Public bucket. No specific SELECT policy needed unless finer control is desired.
INSERT/UPDATE/DELETE (Write): Restrict to authenticated users who are Owners/Managers of the associated restaurant. This requires policies checking the user's role (e.g., via the is_restaurant_staff helper function) and potentially parsing the intended storage path to determine the restaurant context.
      -- Example Policy: Allow Owners/Managers to upload to menu-media
-- NOTE: This requires a reliable way to link the upload path to a restaurant_id,
-- either via metadata or path naming convention (e.g., restaurant_id/...).
-- This conceptual policy assumes a helper function exists.
CREATE POLICY "Staff can manage menu media objects"
ON storage.objects
FOR INSERT, UPDATE, DELETE -- Define for which actions
USING ( bucket_id = 'menu-media' ) -- Apply only to this bucket
WITH CHECK (
  bucket_id = 'menu-media' AND
  is_restaurant_staff(auth.uid(), get_restaurant_id_from_storage_path(name), ARRAY['owner', 'manager'])
);
-- Helper function get_restaurant_id_from_storage_path(path TEXT) needs implementation based on your path strategy.
   
 IGNORE_WHEN_COPYING_START
 content_copy download
 Use code with caution.SQL
IGNORE_WHEN_COPYING_END




Handling Media Input (Upload vs. Link):
UI: Provide two options in the Menu Item form:
A file input (<input type="file">) accepting relevant types (.glb, .gltf, .png, .jpg, .jpeg, .webp, .gif).
A text input (<input type="url">) for pasting an external URL.


Logic: The user interacts with only one of these inputs per save operation.
If File Uploaded:
Use supabase.storage.from('menu-media').upload(filePath, fileBody).
filePath should be unique (e.g., public/${restaurantId}/${menuItemId}/${timestamp}-${fileName}).
On success, get the returned path. Store this path temporarily.
Determine media_type ('3d', 'gif', 'image') from file extension.


If URL Provided:
Validate the input is a plausible URL format. Store this URL temporarily.
Determine media_type (likely 'image' or 'gif' by default for URLs, unless UI allows specifying '3d' for external models).




Retrieving Media Source (URL or Supabase Path):
Logic: When displaying a menu item's media:
Fetch the menu_items record, including external_media_url, media_path, and media_type.
Check external_media_url: If it has a value, use this URL directly as the source (src) for the <img> tag or <model-viewer>.
Else, check media_path: If external_media_url is NULL and media_path has a value:
Generate the public URL using supabase.storage.from('menu-media').getPublicUrl(item.media_path).
Use the resulting publicUrl as the source (src).


Else (both are NULL): Display a default placeholder.




Linking Media to Database Records (menu_items):
On Save: When the "Save Item" / "Create Item" action runs:
If File Was Uploaded: Update the menu_items record setting media_path to the stored path, media_type to the determined type, and explicitly set external_media_url to NULL.
If URL Was Provided: Update the menu_items record setting external_media_url to the provided URL, media_type to the determined type, and explicitly set media_path to NULL.
If No Media Change: Do not modify the media columns.




Deleting Unused Media Files (from Storage): Important for cost/space management.
On Item Deletion: When a menu_item is deleted via the application:
Check if its media_path is NOT NULL.
If it has a media_path, trigger supabase.storage.from('menu-media').remove([item.media_path]). Handle potential errors.


On Media Replacement (Upload): If a user uploads a new file to replace existing media:
Before saving the new media_path, retrieve the old media_path from the item being edited.
After successfully saving the item with the new media_path, delete the old file from storage using supabase.storage.from('menu-media').remove([old_media_path]).


Orphaned File Cleanup (Advanced): Consider a periodic cleanup (manual or automated via Edge Function/pg_cron) comparing storage.objects in the bucket against menu_items.media_path values and deleting orphans. Use extreme caution.


8. Realtime Functionality (Supabase Realtime)
Enabling Realtime:
Go to Database > Replication.
Find supabase_postgres publication. Click table icon.
Toggle ON for tables needing live updates (e.g., orders, order_items, tables).


Subscribing to Changes:
Use Supabase client library: supabase.channel(...).on('postgres_changes', { event: 'INSERT/UPDATE/DELETE', schema: 'public', table: '...', filter: '...' }, payload => { // Update UI }).subscribe()
Use specific channels. Filter events server-side (filter=column=eq.value) for efficiency.
Update frontend UI based on payload.


Use Cases: Live order notifications for staff, real-time table status updates, waiter call notifications.
9. Serverless Functions (Supabase Edge Functions)
Potential Use Cases: Securely handling payment gateway webhooks (PayU Money), running scheduled tasks (pg_cron), complex backend logic, secure third-party API interactions.
Basic Setup: Use Supabase CLI (npm install supabase, npx supabase login, link, functions new, functions deploy). Invoke via supabase.functions.invoke(...).
10. Integration & Data Flow (with Frontend/Lovable.dev)
Connecting: Use Supabase integration in the frontend framework/tool, providing Project URL and anon key.
Fetching Data:
Use Supabase client library (select) or framework data binding.
Crucially fetch media_path, external_media_url, and media_type for menu_items.
Apply filters (eq, in, etc.) and sorting (order). Use DB Views/Functions for complex queries.


Performing CRUD Operations:
Trigger Supabase client methods (insert, update, delete) from UI events.
For Menu Items: Ensure the logic correctly handles saving either media_path (and nullifying external_media_url) or external_media_url (and nullifying media_path) based on user input.
Handle responses (success/error) and update UI.


Handling Data Synchronization: Use Realtime for live updates; provide manual refresh options; ensure workflows update all relevant tables consistently.
11. Data Management & Workflows
Customer Order Flow: Scan QR -> Identify Table -> (Optional Login) -> Fetch Menu (incl. media source check) -> Add to Cart -> Submit Order -> Create orders & order_items records -> (Optional Payment) -> Realtime Notification to Staff.
Menu Update Flow: Login -> Menu Management -> Fetch Items -> Edit Item -> User either uploads file OR provides URL -> Application determines source -> If upload: storage.upload() -> Get path -> On Save: Update menu_items setting correct media_path/external_media_url (nullifying the other) & media_type -> (Optional: Delete old file from storage if replaced).
Staff Management Flow: Login -> Staff Section -> Fetch Staff -> Add Staff -> Collect Details -> Create auth.users record (if needed) -> Create staff record linking user_id, restaurant_id, role.
Data Integrity: Enforce using Database Constraints (NOT NULL, CHECK, UNIQUE, FOREIGN KEY, custom CHECK for media source). Use transactions for multi-step operations (e.g., order + items).
12. Maintenance & Best Practices
Database Backups: Review Supabase automatic backup policy; perform manual backups before major changes.
Monitoring: Use Supabase dashboard (Usage, Logs, Reports).
Security: Prioritize RLS. Protect service_role key. Validate all client input.
Schema Migrations: Use Supabase CLI (migration new, edit SQL, db push) for controlled schema changes.
Cleaning Up Storage: Implement a strategy (manual or automated) to delete orphaned files in the menu-media bucket (See Section 7).
13. Troubleshooting
Connection Issues: Verify URL/anon key, project status, network console.
RLS Policy Errors: Check policy logic (USING/WITH CHECK), user permissions, helper functions. Use EXPLAIN or test policies in SQL Editor.
Storage Access Problems: Verify Bucket Name in code. Check Storage RLS policies (INSERT/UPDATE/DELETE). Check CORS settings on the bucket. Verify file path correctness. Check network console for 403/404 errors.
Debugging Realtime: Verify table replication is ON. Check channel subscription code (filters). Inspect WebSocket messages in dev tools. Verify RLS allows reading the triggering data.

This comprehensive Knowledge Base should provide Cursor AI with the necessary specifications to build the Supabase backend and integrate it correctly, including the flexible media handling. Remember to test thoroughly at each stage.
     
   


